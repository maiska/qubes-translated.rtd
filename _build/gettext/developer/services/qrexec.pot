# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, test
# This file is distributed under the same license as the qubes-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: qubes-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-23 17:29+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../_doc/developer/services/qrexec.rst:1
#: 44d1e5cfca8043809173cbb4bc967508
msgid "(*This page is about qrexec v3. For qrexec v2, see*\\ :doc:`here </developer/services/qrexec2>`\\ *.*)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:4
#: 9143f8cff7684c3ba05d6aab26f616fd
msgid "The **qrexec framework** is used by core Qubes components to implement communication between domains. Qubes domains are strictly isolated by design. However, the OS needs a mechanism to allow the administrative domain (dom0) to force command execution in another domain (VM). For instance, when a user selects an application from the KDE menu, it should start in the selected VM. Also, it is often useful to be able to pass stdin/stdout/stderr from an application running in a VM to dom0 (and the other way around). (For example, so that a VM can notify dom0 that there are updates available for it). By default, Qubes allows VMs initiate such communications in specific circumstances. The qrexec framework generalizes this process by providing a remote procedure call (RPC) protocol for the Qubes architecture. It allows users and developers to use and design secure inter-VM tools."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:19
#: 729c4c02832447de9ada5c7145f5c596
msgid "Qrexec basics: architecture and examples"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:21
#: 7e44ac61998340bf8ba69fbaa9ccbd00
msgid "Qrexec is built on top of *vchan*, a Xen library providing data links between VMs. During domain startup , a process named ``qrexec-daemon`` is started in dom0, and a process named ``qrexec-agent`` is started in the VM. They are connected over a **vchan** channel. ``qrexec-daemon`` listens for connections from a dom0 utility named ``qrexec-client``. Let’s say we want to start a process (call it ``VMprocess``) in a VM (``someVM``). Typically, the first thing that a ``qrexec-client`` instance does is to send a request to the ``qrexec-daemon``, which in turn relays it to ``qrexec-agent`` running in ``someVM``. ``qrexec-daemon`` assigns unique vchan connection details and sends them to both ``qrexec-client`` (in dom0) and ``qrexec-agent`` (in ``someVM``). ``qrexec-client`` starts a vchan server, which ``qrexec-agent`` then connects to. Once this channel is established, stdin/stdout/stderr from the VMprocess is passed between ``qrexec-agent`` and the ``qrexec-client`` process."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:40
#: 26ae89b86ee2411c8331e533c42e5795
msgid "qrexec basics diagram"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:42
#: 06ca1d1ac51140e7ad9f5fbb8d323160
msgid "The ``qrexec-client`` command is used to make connections to VMs from dom0. For example, the following command creates an empty file called ``hello-world.txt`` in the home folder of ``someVM``:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:50
#: 5bfadff08a4b469491889b753e994ca7
msgid "The string before the colon specifies what user to run the command as. The ``-e`` flag tells ``qrexec-client`` to exit immediately after sending the execution request and receiving a status code from ``qrexec-agent`` (whether the process creation succeeded). With this option, no further data is passed between the domains. By contrast, the following command demonstrates an open channel between dom0 and someVM (in this case, a remote shell):"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:62
#: 7c42de47fb0a47968c38a8737bfa82c1
msgid "The ``qvm-run`` command is heavily based on ``qrexec-client``. It also takes care of additional activities, e.g. starting the domain if it is not up yet and starting the GUI daemon. Thus, it is usually more convenient to use ``qvm-run``."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:67
#: 40a58d42074c488792359e9b81fcc3da
msgid "There can be an almost arbitrary number of ``qrexec-client`` processes for a given domain. The limiting factor is the number of available vchan channels, which depends on the underlying hypervisor, as well the domain’s OS."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:72
#: a54a4887035c406db33612b113fc39d0
msgid "For more details on the qrexec framework and protocol, see “:doc:`Qubes RPC internals </developer/services/qrexec-internals>`.”"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:76
#: 5702b2dab49d4925b5474ff3a637e59a
msgid "Qubes RPC services"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:78
#: 6966a0f097cd4d42a2b82ea1fe2eb3ec
msgid "Some common tasks (like copying files between VMs) have an RPC-like structure: a process in one VM (say, the file sender) needs to invoke and send/receive data to some process in other VM (say, the file receiver). The Qubes RPC framework was created to securely facilitate a range of such actions."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:84
#: 145b6196610445d1a960043c5f55d2ea
msgid "Obviously, inter-VM communication must be tightly controlled to prevent one VM from taking control of another, possibly more privileged, VM. Therefore the design decision was made to pass all control communication via dom0, that can enforce proper authorization. Then, it is natural to reuse the already-existing qrexec framework."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:90
#: 9a8a96abf49c4211b7dcd411a0f01eea
msgid "Also, note that bare qrexec provides ``VM <-> dom0`` connectivity, but the command execution is always initiated by dom0. There are cases when VM needs to invoke and send data to a command in dom0 (e.g. to pass information on newly installed ``.desktop`` files). Thus, the framework allows dom0 to be the RPC target as well."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:96
#: 8afd6a377f3841d6b53f71ccfa68daad
msgid "Thanks to the framework, RPC programs are very simple – both RPC client and server just use their stdin/stdout to pass data. The framework does all the inner work to connect these processes to each other via ``qrexec-daemon`` and ``qrexec-agent``. Additionally, disposable VMs are tightly integrated – RPC to a DisposableVM is identical to RPC to a normal domain, all one needs is to pass ``@dispvm`` as the remote domain name."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:105
#: a0cbfddebdac4ea584c11e96d8940c16
msgid "Qubes RPC administration"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:108
#: 198aba76eae64506b387cbb83f89ac87
msgid "Policy files"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:110
#: 96cba0a3c17848c7bc127f27f498e564
msgid "The dom0 directory ``/etc/qubes-rpc/policy/`` contains a file for each available RPC action that a VM might call. Together the contents of these files make up the RPC access policy database. Policies are defined in lines with the following format:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:119
#: 2279c481f06848e2a45deabfe56cec07
msgid "You can specify srcvm and destvm by name or by one of the reserved keywords such as ``@anyvm``, ``@dispvm``, or ``dom0``. (Of these three, only ``@anyvm`` keyword makes sense in the srcvm field. Service calls from dom0 are currently always allowed, and ``@dispvm`` means “new VM created for this particular request,” so it is never a source of request.) Other methods using *tags* and *types* are also available (and discussed below)."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:127
#: 756e33ec9c0043e39922c8575332eb3b
msgid "Whenever a RPC request for an action is received, the domain checks the first matching line of the relevant file in ``/etc/qubes-rpc/policy/`` to determine access: whether to allow the request, what VM to redirect the execution to, and what user account the program should run under. Note that if the request is redirected (``target=`` parameter), policy action remains the same – even if there is another rule which would otherwise deny such request. If no policy rule is matched, the action is denied. If the policy file does not exist, the user is prompted to create one. If there is still no policy file after prompting, the action is denied."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:138
#: a4ce908bdb734a7495e4a44878aebd60
msgid "In the target VM, a file in either of the following locations must exist, containing the file name of the program that will be invoked, or being that program itself – in which case it must have executable permission set (``chmod +x``): - ``/etc/qubes-rpc/RPC_ACTION_NAME`` when you make it in the template qube; - ``/usr/local/etc/qubes-rpc/RPC_ACTION_NAME`` for making it only in an app qube."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:147
#: 14c07c5bcae84ef4acd8f38cb4b82f5d
msgid "Making an RPC call"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:149
#: 6b90eb7142004acf8e1610dd602457b5
msgid "From outside of dom0, RPC calls take the following form:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:155
#: d87556f4de034a1ea9f5b834d085b60e
msgid "For example:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:161
#: c385a337b86f4b888e433a86833136c3
msgid "Note that only stdin/stdout is passed between RPC server and client – notably, no command line arguments are passed. By default, stderr of client and server is logged in the syslog/journald of the VM where the process is running."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:166
#: 04bc38f935744914ba761cffff79d144
msgid "It is also possible to call service without specific client program – in which case server stdin/out will be connected with the terminal:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:174
#: b7b35838d5f24f16800671c1dbd5ba5d
msgid "Specifying VMs: tags, types, targets, etc."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:176
#: ae8639e1471e48cd81219381674310bd
msgid "There are severals methods for specifying source/target VMs in RPC policies."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:179
#: f5768636f62f4f498c65e82c05566475
msgid "``@tag:some-tag`` - meaning a VM with tag ``some-tag``"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:180
#: 24f05b14753347bbaf7225426634d1c8
msgid "``@type:type`` - meaning a VM of ``type`` (like ``AppVM``, ``TemplateVM`` etc)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:183
#: 8f22d0941b564b8183d76418020bbf42
msgid "Target VM can be also specified as ``@default``, which matches the case when calling VM didn’t specified any particular target (either by using ``@default`` target, or empty target). For DisposableVMs, ``@dispvm:DISP_VM`` is very similar to ``@dispvm`` but forces using a particular VM (``DISP_VM``) as a base VM to be started as DisposableVM. For example:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:194
#: ced49cdf03944059b847bddb670d1214
msgid "Adding such policy itself will not force usage of this particular ``DISP_VM`` - it will only allow it when specified by the caller. But ``@dispvm:DISP_VM`` can also be used as target in request redirection, so *it is possible* to force particular ``DISP_VM`` usage, when caller didn’t specify it:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:204
#: 37ac2426e9ae4b799447b501a92e1cf6
msgid "Note that without redirection, this rule would allow using default Disposable VM (``default_dispvm`` VM property, which itself defaults to global ``default_dispvm`` property). Also note that the request will be allowed (``allow`` action) even if there is no second rule allowing calls to ``@dispvm:anon-whonix-dvm``, or even if there is a rule explicitly denying it. This is because the redirection happens *after* considering the action."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:212
#: 34692ca302d94aa492ca05002400450c
msgid "The policy confirmation dialog (``ask`` action) allows the user to specify target VM. User can choose from VMs that, according to policy, would lead to ``ask`` or ``allow`` actions. It is not possible to select VM that policy would deny. By default no VM is selected, even if the caller provided some, but policy can specify default value using ``default_target=`` parameter. For example:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:225
#: 1d16af0d1e914e78be587a50483a4845
msgid "The first rule allow call from ``work-mail`` to ``work-archive``, without any confirmation. The second rule will ask the user about calls from ``work-mail`` VM to any VM with tag ``work``. And the confirmation dialog will have ``work-files`` VM chosen by default, regardless of the VM specified by the caller (``work-mail`` VM). The third rule allow the caller to not specify target VM at all and let the user choose, still - from VMs with tag ``work`` (and ``work-archive``, regardless of tag), and with ``work-files`` as default."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:235
#: 9c1f070020244862853dcd586fc5b286
msgid "RPC services and security"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:237
#: 476bc8352c4246f98a5d1e65ccb1793a
msgid "Be very careful when coding and adding a new RPC service. Unless the offered functionality equals full control over the target (it is the case with e.g. ``qubes.VMShell`` action), any vulnerability in an RPC server can be fatal to Qubes security. On the other hand, this mechanism allows to delegate processing of untrusted input to less privileged (or disposable) AppVMs, thus wise usage of it increases security."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:244
#: 61d237b7cd0b46cca52eb3d2eedad889
msgid "For example, this command will run the ``firefox`` command in a DisposableVM based on ``work``:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:251
#: dc05c958ec134595a5f5f6c5df493cd0
msgid "By contrast, consider this command:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:257
#: 812fe80c9311447d9b87bd452556857e
msgid "This will look for a ``firefox.desktop`` file in a standard location in a DisposableVM based on ``work``, then launch the application described by that file. The practical difference is that the bare ``qvm-run`` command uses the ``qubes.VMShell`` service, which allows you to run an arbitrary command with arbitrary arguments, essentially providing full control over the target VM. By contrast, the ``qubes.StartApp`` service allows you to run only applications that are advertised in ``/usr/share/applications`` (or other standard locations) *without* control over the arguments, so giving a VM access to ``qubes.StartApp`` is much safer. While there isn’t much practical difference between the two commands above when starting an application from dom0 in Qubes 4.0, there is a significant security risk when launching applications from a domU (e.g., from a separate GUI domain). This is why ``qubes.StartApp`` uses our standard ``qrexec`` argument grammar to strictly filter the permissible grammar of the ``Exec=`` lines in ``.desktop`` files that are passed from untrusted domUs to dom0, thereby protecting dom0 from command injection by maliciously-crafted ``.desktop`` files."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:276
#: 49e36146d89344e0921bfaf053124bb9
msgid "Service policies with arguments"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:278
#: b8c1974db8394a54981eba468f67b6f7
msgid "Sometimes a service name alone isn’t enough to make reasonable qrexec policy. One example of such a situation is :doc:`qrexec-based USB passthrough </user/how-to-guides/how-to-use-usb-devices>`. Using just a service name would make it difficult to express the policy “allow access to devices X and Y, but deny to all others.” It isn’t feasible to create a separate service for every device: we would need to change the code in multiple files any time we wanted to update the service."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:286
#: 00d2743e7cf1453bafa31a844b471056
msgid "For this reason it is possible to specify a service argument, which will be subject to a policy. A service argument can make service policies more fine-grained. With arguments, it is easier to write more precise policies using the “allow” and “deny” actions, instead of relying on the “ask” method. (Writing too many “ask” policies offloads additional decisions to the user. Generally, the fewer choices the user must make, the lower the chance to make a mistake.)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:294
#: a61d2fa932d94e19852ccb35d915f03e
msgid "Each specific argument that we want to use needs its own policy in dom0 at a path like ``/etc/qubes-rpc/policy/RPC_ACTION_NAME+ARGUMENT``. So for instance, we might have policies called ``test.Device``, ``test.Device+device1`` and ``test.Device+device2``. If the policy for the specific argument is not set (that is, if no file exists for ``RPC_ACTION_NAME+ARGUMENT``), then dom0 uses the default policy with no argument for this service."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:302
#: 88860f1272264007a05fc413d774cd1a
msgid "When calling a service that takes an argument, just add the argument to the service name separated with ``+``."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:309
#: d8485c6999bf4a0a871a83919f675e93
msgid "The script will receive ``ARGUMENT`` as its argument. The argument will also become available as the ``QREXEC_SERVICE_ARGUMENT`` environment variable. This means it is possible to install a different script for a particular service argument."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:314
#: 7e41f4b422d04f139d3dc94b64282702
msgid "See `below <#rpc-service-with-argument-file-reader>`__ for an example of an RPC service using an argument."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:322
#: 86a192a6191c48e7beb99a37b0766c0a
msgid "Qubes RPC examples"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:324
#: 49d2455be8044e2484050916401e7380
msgid "To demonstrate some of the possibilities afforded by the qrexec framework, here are two examples of custom RPC services."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:328
#: 56befa60177f4e62b9b0f4062ac650b7
msgid "Simple RPC service (addition)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:330
#: fdaf36929e91468f8db4ab386d5d5906
msgid "We can create an RPC service that adds two integers in a target domain (the server, call it “anotherVM”) and returns back the result to the invoker (the client, “someVM”). In someVM, create a file with the following contents and save it with the path ``/usr/bin/our_test_add_client``:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:342
#: d16c3e31b7b74179aa13e3af00ae42b1
msgid "Our server will be anotherVM at ``/usr/bin/our_test_add_server``. The code for this file is:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:351
#: 93d799fa3fcd46648b438b9420b6e2e9
msgid "We’ll need to create a service called ``test.Add`` with its own definition and policy file in dom0. Now we need to define what the service does. In this case, it should call our addition script. We define the service with a symlink at ``/etc/qubes-rpc/test.Add`` pointing to our server script (the script can be also placed directly in ``/etc/qubes-rpc/test.Add`` - make sure the file has executable bit set!):"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:363
#: 449e2fae04674af8b6299480ffb50b91
msgid "The administrative domain will direct traffic based on the current RPC policies. In dom0, create a file at ``/etc/qubes-rpc/policy/test.Add`` containing the following:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:371
#: 05c9dd0668624df19170f008f970984d
msgid "This will allow our client and server to communicate."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:373
#: 85302d0713d541d792f9435a40a9f818
msgid "Before we make the call, ensure that the client and server scripts have executable permissions. Finally, invoke the RPC service."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:380
#: e59e99ea290b4cf3aba558f98856cffd
msgid "We should get “3” as answer. (dom0 will ask for confirmation first.)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:382
#: f33ee9960a7946fa85f541a2e645bca3
msgid "**Note:** For a real world example of writing a qrexec service, see this `blog post <https://blog.invisiblethings.org/2013/02/21/converting-untrusted-pdfs-into-trusted.html>`__."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:387
#: 361ee70d88af4900b7567ed353f5b657
msgid "RPC service with argument (file reader)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:389
#: d396e6747fa84edc9dee1d3a61b79c1c
msgid "Here we create an RPC call that reads a specific file from a predefined directory on the target. This example uses an `argument <#service-policies-with-arguments>`__ to the policy. In this example a simplified workflow will be used. The service code is placed directly in the service definition file on the target VM. No separate client script will be needed."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:396
#: 16ea88bf0230401d8cb65173aad09702
msgid "First, on your target VM, create two files in the home directory: ``testfile1`` and ``testfile2``. Have them contain two different “Hello world!” lines."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:400
#: b983b59658d046e2b2e39a93c2a5071d
msgid "Next, we define the RPC service. On the target VM, place the code below at ``/etc/qubes-rpc/test.File``:"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:413
#: ecbf364a19d6496a899afdb191896760
msgid "Make sure the file is executable! (The service argument is already sanitized by qrexec framework. It is guaranteed to not contain any spaces or slashes, so there should be no need for additional path sanitization.)"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:418
#: da8a38efa080477baf04a99b9667a3cf
msgid "Now we create three policy files in dom0. See the table below for details. Replace “source_vm1” and others with the names of your own chosen domains."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:422
#: 877717463a1a479e82428da13d432537
msgid "\\|————————————————————————\\| \\| Path to file in dom0 \\| Policy contents \\| \\|——————————————-+—————————-\\| \\| /etc/qubes-rpc/policy/test.File \\| @anyvm @anyvm deny \\| \\| /etc/qubes-rpc/policy/test.File+testfile1 \\| source_vm1 target_vm allow \\| \\| /etc/qubes-rpc/policy/test.File+testfile2 \\| source_vm2 target_vm allow \\| \\|————————————————————————\\|"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:429
#: 3609525a2da34082a323dcdbe108df17
msgid "With this done, we can run some tests. Invoke RPC from ``source_vm1`` via"
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:436
#: 2c5bdaab49d34d44bf328f88d372e77a
msgid "We should get the contents of ``/home/user/testfile1`` printed to the terminal. Invoking the service from ``source_vm2`` should work the same, and ``testfile2`` should also work."
msgstr ""

#: ../../../_doc/developer/services/qrexec.rst:445
#: 61bab683997b4c8ea8e2bea210fd3853
msgid "But when invoked with other arguments or from a different VM, it should be denied."
msgstr ""
